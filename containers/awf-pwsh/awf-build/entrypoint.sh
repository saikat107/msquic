#!/bin/bash
set -e

echo "[entrypoint] Agentic Workflow Firewall - Agent Container"
echo "[entrypoint] =================================="

# Adjust awfuser UID/GID to match host user at runtime
# This ensures file ownership is correct regardless of whether using GHCR images or local builds
HOST_UID=${AWF_USER_UID:-$(id -u awfuser)}
HOST_GID=${AWF_USER_GID:-$(id -g awfuser)}
CURRENT_UID=$(id -u awfuser)
CURRENT_GID=$(id -g awfuser)

# Validate UID/GID values to prevent security issues
if ! [[ "$HOST_UID" =~ ^[0-9]+$ ]]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_UID: must be numeric"
  exit 1
fi

if ! [[ "$HOST_GID" =~ ^[0-9]+$ ]]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_GID: must be numeric"
  exit 1
fi

# Prevent setting UID/GID to 0 (root) which defeats the privilege drop
if [ "$HOST_UID" -eq 0 ]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_UID: cannot be 0 (root)"
  exit 1
fi

if [ "$HOST_GID" -eq 0 ]; then
  echo "[entrypoint][ERROR] Invalid AWF_USER_GID: cannot be 0 (root)"
  exit 1
fi

if [ "$CURRENT_UID" != "$HOST_UID" ] || [ "$CURRENT_GID" != "$HOST_GID" ]; then
  echo "[entrypoint] Adjusting awfuser UID:GID from $CURRENT_UID:$CURRENT_GID to $HOST_UID:$HOST_GID"
  
  # Check if target GID is already in use by another group
  EXISTING_GROUP=$(getent group "$HOST_GID" 2>/dev/null | cut -d: -f1 || true)
  if [ -n "$EXISTING_GROUP" ] && [ "$EXISTING_GROUP" != "awfuser" ]; then
    echo "[entrypoint][WARN] Target GID $HOST_GID is already used by group '$EXISTING_GROUP'. Skipping GID change."
  else
    # Change GID first (must be done before UID change)
    if ! groupmod -g "$HOST_GID" awfuser 2>/dev/null; then
      echo "[entrypoint][ERROR] Failed to change GID of awfuser to $HOST_GID"
      exit 1
    fi
  fi
  
  # Check if target UID is already in use by another user
  EXISTING_USER=$(getent passwd "$HOST_UID" 2>/dev/null | cut -d: -f1 || true)
  if [ -n "$EXISTING_USER" ] && [ "$EXISTING_USER" != "awfuser" ]; then
    echo "[entrypoint][WARN] Target UID $HOST_UID is already used by user '$EXISTING_USER'. Skipping UID change."
  else
    # Change UID
    if ! usermod -u "$HOST_UID" awfuser 2>/dev/null; then
      echo "[entrypoint][ERROR] Failed to change UID of awfuser to $HOST_UID"
      exit 1
    fi
  fi
  
  # Fix ownership of awfuser's home directory
  chown -R awfuser:awfuser /home/awfuser 2>/dev/null || true
  echo "[entrypoint] UID/GID adjustment complete"
fi

# Fix DNS configuration - ensure external DNS works alongside Docker's embedded DNS
# Docker's embedded DNS (127.0.0.11) is used for service name resolution (e.g., squid-proxy)
# Trusted external DNS servers are used for internet domain resolution
echo "[entrypoint] Configuring DNS..."
if [ -f /etc/resolv.conf ]; then
  # Backup original resolv.conf
  cp /etc/resolv.conf /etc/resolv.conf.orig

  # Get DNS servers from environment (default to Google DNS)
  DNS_SERVERS="${AWF_DNS_SERVERS:-8.8.8.8,8.8.4.4}"

  # Create new resolv.conf with Docker embedded DNS first, then trusted external DNS servers
  {
    echo "# Generated by awf entrypoint"
    echo "# Docker embedded DNS for service name resolution (squid-proxy, etc.)"
    echo "nameserver 127.0.0.11"
    echo "# Trusted external DNS servers for internet domain resolution"

    # Add each trusted DNS server
    IFS=',' read -ra DNS_ARRAY <<< "$DNS_SERVERS"
    for dns_server in "${DNS_ARRAY[@]}"; do
      dns_server=$(echo "$dns_server" | tr -d ' ')
      if [ -n "$dns_server" ]; then
        echo "nameserver $dns_server"
      fi
    done

    echo "options ndots:0"
  } > /etc/resolv.conf

  echo "[entrypoint] DNS configured with Docker embedded DNS (127.0.0.11) and trusted servers: $DNS_SERVERS"
fi

# Update CA certificates if SSL Bump is enabled
# The CA certificate is mounted at /usr/local/share/ca-certificates/awf-ca.crt
if [ "${AWF_SSL_BUMP_ENABLED}" = "true" ]; then
  echo "[entrypoint] SSL Bump mode detected - updating CA certificates..."
  if [ -f /usr/local/share/ca-certificates/awf-ca.crt ]; then
    update-ca-certificates 2>/dev/null
    echo "[entrypoint] CA certificates updated for SSL Bump"
    echo "[entrypoint] ⚠️  WARNING: HTTPS traffic will be intercepted for URL inspection"
  else
    echo "[entrypoint][WARN] SSL Bump enabled but CA certificate not found"
  fi
fi

# Setup iptables rules
/usr/local/bin/setup-iptables.sh

# Print proxy environment
echo "[entrypoint] Proxy configuration:"
echo "[entrypoint]   HTTP_PROXY=$HTTP_PROXY"
echo "[entrypoint]   HTTPS_PROXY=$HTTPS_PROXY"

# Print network information
echo "[entrypoint] Network information:"
echo "[entrypoint]   IP address: $(hostname -I)"
echo "[entrypoint]   Hostname: $(hostname)"

# Configure git safe directories for awfuser
# Use runuser instead of su to avoid PAM session issues
runuser -u awfuser -- git config --global --add safe.directory '*' 2>/dev/null || true

echo "[entrypoint] =================================="

# Determine which capabilities to drop
# - CAP_NET_ADMIN is always dropped (prevents iptables bypass)
# - CAP_SYS_CHROOT is dropped when chroot mode is enabled (prevents user code from using chroot)
# - CAP_SYS_ADMIN is dropped when chroot mode is enabled (was needed for mounting procfs)
if [ "${AWF_CHROOT_ENABLED}" = "true" ]; then
  CAPS_TO_DROP="cap_net_admin,cap_sys_chroot,cap_sys_admin"
  echo "[entrypoint] Chroot mode enabled - dropping CAP_NET_ADMIN, CAP_SYS_CHROOT, and CAP_SYS_ADMIN"
else
  CAPS_TO_DROP="cap_net_admin"
  echo "[entrypoint] Dropping CAP_NET_ADMIN capability"
fi

echo "[entrypoint] Switching to awfuser (UID: $(id -u awfuser), GID: $(id -g awfuser))"
echo "[entrypoint] Executing command: $@"
echo ""

# If chroot mode is enabled, run user command INSIDE the chroot /host
# This provides transparent host binary access - user command sees host filesystem as /
if [ "${AWF_CHROOT_ENABLED}" = "true" ]; then
  echo "[entrypoint] Chroot mode: running command inside host filesystem (/host)"

  # Mount a container-scoped procfs at /host/proc
  # This provides dynamic /proc/self/exe resolution (required by .NET CLR, JVM, and other
  # runtimes that read /proc/self/exe to find themselves). A static bind mount of /proc/self
  # always resolves to the parent shell's exe, causing runtime failures.
  # Security: This procfs is container-scoped (only shows container processes, not host).
  # SYS_ADMIN capability (required for mount) is dropped before user code runs.
  mkdir -p /host/proc
  if mount -t proc -o nosuid,nodev,noexec proc /host/proc; then
    echo "[entrypoint] Mounted procfs at /host/proc (nosuid,nodev,noexec)"
  else
    echo "[entrypoint][ERROR] Failed to mount procfs at /host/proc"
    echo "[entrypoint][ERROR] This is required for Java, .NET, and other runtimes that read /proc/self/exe"
    echo "[entrypoint][ERROR] Ensure the container has SYS_ADMIN capability (it will be dropped before user code runs)"
    exit 1
  fi

  # Verify capsh is available on the host (required for privilege drop)
  if ! chroot /host which capsh >/dev/null 2>&1; then
    echo "[entrypoint][ERROR] capsh not found on host system"
    echo "[entrypoint][ERROR] Install libcap2-bin package: apt-get install libcap2-bin"
    exit 1
  fi

  # Backup and copy container's resolv.conf to host (preserves AWF DNS configuration)
  # This ensures DNS queries inside the chroot use the configured DNS servers
  # NOTE: We backup the host's original resolv.conf and set up a trap to restore it
  RESOLV_BACKUP="/host/etc/resolv.conf.awf-backup-$$"
  RESOLV_MODIFIED=false
  RESOLV_CREATED=false
  if [ -f /host/etc/resolv.conf ]; then
    # File exists: backup original and replace with AWF DNS configuration
    if cp /host/etc/resolv.conf "$RESOLV_BACKUP" 2>/dev/null; then
      if cp /etc/resolv.conf /host/etc/resolv.conf.awf 2>/dev/null; then
        mv /host/etc/resolv.conf.awf /host/etc/resolv.conf 2>/dev/null && RESOLV_MODIFIED=true
        echo "[entrypoint] DNS configuration copied to chroot (backup at $RESOLV_BACKUP)"
      else
        echo "[entrypoint][WARN] Could not copy DNS configuration to chroot"
      fi
    else
      echo "[entrypoint][WARN] Could not backup host resolv.conf, skipping DNS override"
    fi
  else
    # File doesn't exist: selective /etc mounts don't include resolv.conf
    # Create it from the container's resolv.conf (which has AWF DNS config)
    if cp /etc/resolv.conf /host/etc/resolv.conf 2>/dev/null; then
      RESOLV_CREATED=true
      echo "[entrypoint] DNS configuration created in chroot (/host/etc/resolv.conf)"
    else
      echo "[entrypoint][WARN] Could not create DNS configuration in chroot"
    fi
  fi

  # Inject host.docker.internal into chroot's /etc/hosts when host access is enabled
  # Docker adds this to the container's /etc/hosts via extra_hosts, but the chroot
  # uses a separate hosts file that doesn't have it. The container's /etc/hosts has
  # the correct mapping, so we copy it to the chroot's /etc/hosts.
  HOSTS_MODIFIED=false
  if [ "${AWF_ENABLE_HOST_ACCESS}" = "1" ]; then
    HOST_DOCKER_ENTRY=$(grep "host.docker.internal" /etc/hosts 2>/dev/null | head -1 || true)
    if [ -n "$HOST_DOCKER_ENTRY" ] && ! grep -q "host.docker.internal" /host/etc/hosts 2>/dev/null; then
      if echo "$HOST_DOCKER_ENTRY" >> /host/etc/hosts 2>/dev/null; then
        HOSTS_MODIFIED=true
        echo "[entrypoint] Added host.docker.internal to chroot /etc/hosts"
      else
        echo "[entrypoint][WARN] Could not add host.docker.internal to chroot /etc/hosts"
      fi
    fi
  fi

  # Determine working directory inside the chroot
  # AWF_WORKDIR is set by docker-manager.ts (containerWorkDir or HOME)
  # For chroot mode, paths like /home/user stay the same (no /host prefix)
  CONTAINER_WORKDIR="${AWF_WORKDIR:-${HOME:-/}}"
  if [ -n "${CONTAINER_WORKDIR}" ] && [ "${CONTAINER_WORKDIR#/host}" != "${CONTAINER_WORKDIR}" ]; then
    # Strip /host prefix if present (for paths that include it)
    CHROOT_WORKDIR="${CONTAINER_WORKDIR#/host}"
    [ -z "${CHROOT_WORKDIR}" ] && CHROOT_WORKDIR="/"
  else
    # Use the path as-is (normal paths like /home/user, /tmp, etc.)
    CHROOT_WORKDIR="${CONTAINER_WORKDIR}"
  fi
  echo "[entrypoint] Chroot working directory: ${CHROOT_WORKDIR}"

  # Validate working directory exists in chroot
  if [ ! -d "/host${CHROOT_WORKDIR}" ]; then
    echo "[entrypoint][WARN] Working directory ${CHROOT_WORKDIR} does not exist on host, will use /"
  fi

  # Find the user name on the host system by UID
  # This allows us to run as the same user inside the chroot
  HOST_USER_UID="${AWF_USER_UID:-1000}"
  HOST_USER=$(chroot /host getent passwd "${HOST_USER_UID}" 2>/dev/null | cut -d: -f1 || echo "")
  if [ -z "${HOST_USER}" ]; then
    # Fall back to 'nobody' if user not found by UID
    HOST_USER="nobody"
    echo "[entrypoint][WARN] Could not find user with UID ${HOST_USER_UID} on host, using ${HOST_USER}"
  else
    echo "[entrypoint] Running as host user: ${HOST_USER} (UID: ${HOST_USER_UID})"
  fi

  # Write the command to a temporary script file in the chroot
  # This avoids complex quoting issues with nested shells
  SCRIPT_FILE="/tmp/awf-cmd-$$.sh"

  # Use host's actual PATH if provided, otherwise construct a default
  # This ensures we use the same Python/Node/Go versions as the host
  if [ -n "${AWF_HOST_PATH}" ]; then
    echo "[entrypoint] Using host PATH for chroot"
    cat > "/host${SCRIPT_FILE}" << AWFEOF
#!/bin/bash
# Use the host's actual PATH (passed via AWF_HOST_PATH)
export PATH="${AWF_HOST_PATH}"
AWFEOF
    # Add CARGO_HOME/bin to PATH if provided (for Rust/Cargo on GitHub Actions)
    if [ -n "${AWF_CARGO_HOME}" ]; then
      echo "[entrypoint] Adding CARGO_HOME/bin to PATH: ${AWF_CARGO_HOME}/bin"
      echo "export PATH=\"${AWF_CARGO_HOME}/bin:\$PATH\"" >> "/host${SCRIPT_FILE}"
      echo "export CARGO_HOME=\"${AWF_CARGO_HOME}\"" >> "/host${SCRIPT_FILE}"
    fi
    # Add JAVA_HOME/bin to PATH if provided (for Java on GitHub Actions)
    # Also set LD_LIBRARY_PATH to include Java's lib directory for libjli.so
    if [ -n "${AWF_JAVA_HOME}" ]; then
      echo "[entrypoint] Adding JAVA_HOME/bin to PATH: ${AWF_JAVA_HOME}/bin"
      echo "export PATH=\"${AWF_JAVA_HOME}/bin:\$PATH\"" >> "/host${SCRIPT_FILE}"
      echo "export JAVA_HOME=\"${AWF_JAVA_HOME}\"" >> "/host${SCRIPT_FILE}"
      # Java needs LD_LIBRARY_PATH to find libjli.so and other shared libs
      echo "export LD_LIBRARY_PATH=\"${AWF_JAVA_HOME}/lib:${AWF_JAVA_HOME}/lib/server:\$LD_LIBRARY_PATH\"" >> "/host${SCRIPT_FILE}"
    fi
    # Add DOTNET_ROOT to PATH if provided (for .NET on GitHub Actions)
    if [ -n "${AWF_DOTNET_ROOT}" ]; then
      echo "[entrypoint] Adding DOTNET_ROOT to PATH: ${AWF_DOTNET_ROOT}"
      echo "export PATH=\"${AWF_DOTNET_ROOT}:\$PATH\"" >> "/host${SCRIPT_FILE}"
      echo "export DOTNET_ROOT=\"${AWF_DOTNET_ROOT}\"" >> "/host${SCRIPT_FILE}"
    fi
    # Add GOROOT/bin to PATH if provided (required for Go on GitHub Actions with trimmed binaries)
    # This ensures the correct Go version is found even if AWF_HOST_PATH has wrong ordering
    if [ -n "${AWF_GOROOT}" ]; then
      echo "[entrypoint] Adding GOROOT/bin to PATH: ${AWF_GOROOT}/bin"
      echo "export PATH=\"${AWF_GOROOT}/bin:\$PATH\"" >> "/host${SCRIPT_FILE}"
      echo "export GOROOT=\"${AWF_GOROOT}\"" >> "/host${SCRIPT_FILE}"
    fi
    # Add BUN_INSTALL/bin to PATH if provided (for Bun on GitHub Actions)
    # Bun must be pre-installed on the host because it crashes inside chroot (restricted /proc)
    if [ -n "${AWF_BUN_INSTALL}" ]; then
      echo "[entrypoint] Adding BUN_INSTALL/bin to PATH: ${AWF_BUN_INSTALL}/bin"
      echo "export PATH=\"${AWF_BUN_INSTALL}/bin:\$PATH\"" >> "/host${SCRIPT_FILE}"
      echo "export BUN_INSTALL=\"${AWF_BUN_INSTALL}\"" >> "/host${SCRIPT_FILE}"
    fi
  else
    echo "[entrypoint] Constructing default PATH for chroot"
    cat > "/host${SCRIPT_FILE}" << 'AWFEOF'
#!/bin/bash
# Set comprehensive PATH for host binaries
# Include standard paths plus tool cache locations (GitHub Actions)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
# Add tool cache paths if they exist (Python, Node, Go, etc.)
[ -d "/opt/hostedtoolcache" ] && export PATH="/opt/hostedtoolcache/node/*/x64/bin:/opt/hostedtoolcache/Python/*/x64/bin:/opt/hostedtoolcache/go/*/x64/bin:$PATH"
# Add user's local bin if it exists
[ -d "$HOME/.local/bin" ] && export PATH="$HOME/.local/bin:$PATH"
# Add Cargo bin for Rust (common in development)
[ -d "$HOME/.cargo/bin" ] && export PATH="$HOME/.cargo/bin:$PATH"
AWFEOF
    # Add GOROOT/bin to PATH if provided (required for Go on GitHub Actions with trimmed binaries)
    # This ensures the correct Go version is found even if PATH has wrong ordering
    if [ -n "${AWF_GOROOT}" ]; then
      echo "[entrypoint] Adding GOROOT/bin to PATH: ${AWF_GOROOT}/bin"
      echo "export PATH=\"${AWF_GOROOT}/bin:\$PATH\"" >> "/host${SCRIPT_FILE}"
      echo "export GOROOT=\"${AWF_GOROOT}\"" >> "/host${SCRIPT_FILE}"
    fi
  fi
  # Append the actual command arguments
  printf '%q ' "$@" >> "/host${SCRIPT_FILE}"
  echo "" >> "/host${SCRIPT_FILE}"
  chmod +x "/host${SCRIPT_FILE}"

  # Execute inside chroot:
  # 1. chroot /host - filesystem root becomes host's /
  # 2. cd to the working directory
  # 3. Drop capabilities (NET_ADMIN and SYS_CHROOT)
  # 4. Run as the mapped user using capsh --user
  # 5. Clean up the script file and restore resolv.conf
  #
  # Note: We use capsh inside the chroot because it handles the privilege drop
  # and user switch atomically. The host must have capsh installed.

  # Build cleanup command that restores resolv.conf if it was modified
  # The backup path uses the chroot perspective (no /host prefix)
  CLEANUP_CMD="rm -f ${SCRIPT_FILE}"
  if [ "$RESOLV_MODIFIED" = "true" ]; then
    # Convert backup path from container perspective (/host/etc/...) to chroot perspective (/etc/...)
    CHROOT_RESOLV_BACKUP="${RESOLV_BACKUP#/host}"
    CLEANUP_CMD="${CLEANUP_CMD}; mv '${CHROOT_RESOLV_BACKUP}' /etc/resolv.conf 2>/dev/null || true"
    echo "[entrypoint] DNS configuration will be restored on exit"
  elif [ "$RESOLV_CREATED" = "true" ]; then
    # File was created by us; remove it on exit to leave no trace
    CLEANUP_CMD="${CLEANUP_CMD}; rm -f /etc/resolv.conf 2>/dev/null || true"
    echo "[entrypoint] DNS configuration will be removed on exit"
  fi
  if [ "$HOSTS_MODIFIED" = "true" ]; then
    # Remove the specific host.docker.internal line we added (runs inside chroot perspective)
    # Use a precise pattern to avoid accidentally removing unrelated entries
    CLEANUP_CMD="${CLEANUP_CMD}; sed -i '/^[0-9.]\\+[[:space:]]\\+host\\.docker\\.internal\$/d' /etc/hosts 2>/dev/null || true"
    echo "[entrypoint] host.docker.internal will be removed from /etc/hosts on exit"
  fi

  exec chroot /host /bin/bash -c "
    cd '${CHROOT_WORKDIR}' 2>/dev/null || cd /
    trap '${CLEANUP_CMD}' EXIT
    exec capsh --drop=${CAPS_TO_DROP} --user=${HOST_USER} -- -c 'exec ${SCRIPT_FILE}'
  "
else
  # Original behavior - run in container filesystem
  # Drop capabilities and privileges, then execute the user command
  # This prevents malicious code from modifying iptables rules or using chroot
  # Security note: capsh --drop removes capabilities from the bounding set,
  # preventing any process (even if it escalates to root) from acquiring them
  # The order of operations:
  # 1. capsh drops capabilities from the bounding set (cannot be regained)
  # 2. gosu switches to awfuser (drops root privileges)
  # 3. exec replaces the current process with the user command
  exec capsh --drop=$CAPS_TO_DROP -- -c "exec gosu awfuser $(printf '%q ' "$@")"
fi
