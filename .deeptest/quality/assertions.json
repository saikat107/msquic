{
  "test_file": "/home/runner/work/msquic/msquic/src/core/unittest/BbrTest.cpp",
  "test_name": "InitializeComprehensive",
  "language": "cpp",
  "start_line": 52,
  "end_line": 126,
  "total_assertions": 82,
  "assertion_types_present": {
    "exception_handling": false,
    "null_checks": false,
    "equality_checks": true,
    "boundary_checks": true
  },
  "assertions": [
    {
      "line": 71,
      "code": "ASSERT_EQ(Bbr->InitialCongestionWindowPackets, 10u);",
      "type": "equality",
      "operands": [
        "Bbr->InitialCongestionWindowPackets",
        "10u"
      ]
    },
    {
      "line": 74,
      "code": "ASSERT_GT(Bbr->CongestionWindow, 0u);",
      "type": "comparison",
      "operands": [
        "Bbr->CongestionWindow",
        "0u"
      ]
    },
    {
      "line": 75,
      "code": "ASSERT_EQ(Bbr->BytesInFlightMax, Bbr->CongestionWindow / 2);",
      "type": "equality",
      "operands": [
        "Bbr->BytesInFlightMax",
        "Bbr->CongestionWindow / 2"
      ]
    },
    {
      "line": 78,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlCanSend, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlCanSend",
        "nullptr"
      ]
    },
    {
      "line": 79,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlSetExemption, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlSetExemption",
        "nullptr"
      ]
    },
    {
      "line": 80,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlReset, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlReset",
        "nullptr"
      ]
    },
    {
      "line": 81,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetSendAllowance, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetSendAllowance",
        "nullptr"
      ]
    },
    {
      "line": 82,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataSent, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataSent",
        "nullptr"
      ]
    },
    {
      "line": 83,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataInvalidated, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataInvalidated",
        "nullptr"
      ]
    },
    {
      "line": 84,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataAcknowledged, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataAcknowledged",
        "nullptr"
      ]
    },
    {
      "line": 85,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataLost, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataLost",
        "nullptr"
      ]
    },
    {
      "line": 86,
      "code": "ASSERT_EQ(Connection.CongestionControl.QuicCongestionControlOnEcn, nullptr);  // BBR doesn't implement ECN",
      "type": "equality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnEcn",
        "nullptr"
      ]
    },
    {
      "line": 87,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnSpuriousCongestionEvent, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnSpuriousCongestionEvent",
        "nullptr"
      ]
    },
    {
      "line": 88,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlLogOutFlowStatus, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlLogOutFlowStatus",
        "nullptr"
      ]
    },
    {
      "line": 89,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetExemptions, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetExemptions",
        "nullptr"
      ]
    },
    {
      "line": 90,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetBytesInFlightMax, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetBytesInFlightMax",
        "nullptr"
      ]
    },
    {
      "line": 91,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlIsAppLimited, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlIsAppLimited",
        "nullptr"
      ]
    },
    {
      "line": 92,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlSetAppLimited, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlSetAppLimited",
        "nullptr"
      ]
    },
    {
      "line": 93,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetCongestionWindow, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetCongestionWindow",
        "nullptr"
      ]
    },
    {
      "line": 94,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetNetworkStatistics, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetNetworkStatistics",
        "nullptr"
      ]
    },
    {
      "line": 97,
      "code": "ASSERT_FALSE(Bbr->BtlbwFound);",
      "type": "boolean",
      "operands": [
        "Bbr->BtlbwFound"
      ]
    },
    {
      "line": 98,
      "code": "ASSERT_FALSE(Bbr->ExitingQuiescence);",
      "type": "boolean",
      "operands": [
        "Bbr->ExitingQuiescence"
      ]
    },
    {
      "line": 99,
      "code": "ASSERT_FALSE(Bbr->EndOfRecoveryValid);",
      "type": "boolean",
      "operands": [
        "Bbr->EndOfRecoveryValid"
      ]
    },
    {
      "line": 100,
      "code": "ASSERT_FALSE(Bbr->EndOfRoundTripValid);",
      "type": "boolean",
      "operands": [
        "Bbr->EndOfRoundTripValid"
      ]
    },
    {
      "line": 101,
      "code": "ASSERT_FALSE(Bbr->AckAggregationStartTimeValid);",
      "type": "boolean",
      "operands": [
        "Bbr->AckAggregationStartTimeValid"
      ]
    },
    {
      "line": 102,
      "code": "ASSERT_FALSE(Bbr->ProbeRttRoundValid);",
      "type": "boolean",
      "operands": [
        "Bbr->ProbeRttRoundValid"
      ]
    },
    {
      "line": 103,
      "code": "ASSERT_FALSE(Bbr->ProbeRttEndTimeValid);",
      "type": "boolean",
      "operands": [
        "Bbr->ProbeRttEndTimeValid"
      ]
    },
    {
      "line": 104,
      "code": "ASSERT_TRUE(Bbr->RttSampleExpired);",
      "type": "boolean",
      "operands": [
        "Bbr->RttSampleExpired"
      ]
    },
    {
      "line": 105,
      "code": "ASSERT_FALSE(Bbr->MinRttTimestampValid);",
      "type": "boolean",
      "operands": [
        "Bbr->MinRttTimestampValid"
      ]
    },
    {
      "line": 108,
      "code": "ASSERT_EQ(Bbr->BbrState, 0u); // BBR_STATE_STARTUP",
      "type": "equality",
      "operands": [
        "Bbr->BbrState",
        "0u"
      ]
    },
    {
      "line": 109,
      "code": "ASSERT_EQ(Bbr->RecoveryState, 0u); // RECOVERY_STATE_NOT_RECOVERY",
      "type": "equality",
      "operands": [
        "Bbr->RecoveryState",
        "0u"
      ]
    },
    {
      "line": 112,
      "code": "ASSERT_EQ(Bbr->BytesInFlight, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->BytesInFlight",
        "0u"
      ]
    },
    {
      "line": 113,
      "code": "ASSERT_EQ(Bbr->Exemptions, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->Exemptions",
        "0u"
      ]
    },
    {
      "line": 114,
      "code": "ASSERT_EQ(Bbr->RoundTripCounter, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->RoundTripCounter",
        "0u"
      ]
    },
    {
      "line": 115,
      "code": "ASSERT_EQ(Bbr->SlowStartupRoundCounter, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->SlowStartupRoundCounter",
        "0u"
      ]
    },
    {
      "line": 116,
      "code": "ASSERT_EQ(Bbr->PacingCycleIndex, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->PacingCycleIndex",
        "0u"
      ]
    },
    {
      "line": 117,
      "code": "ASSERT_EQ(Bbr->AggregatedAckBytes, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->AggregatedAckBytes",
        "0u"
      ]
    },
    {
      "line": 118,
      "code": "ASSERT_EQ(Bbr->LastEstimatedStartupBandwidth, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->LastEstimatedStartupBandwidth",
        "0u"
      ]
    },
    {
      "line": 121,
      "code": "ASSERT_EQ(Bbr->MinRtt, UINT64_MAX);",
      "type": "equality",
      "operands": [
        "Bbr->MinRtt",
        "UINT64_MAX"
      ]
    },
    {
      "line": 124,
      "code": "ASSERT_FALSE(Bbr->BandwidthFilter.AppLimited);",
      "type": "boolean",
      "operands": [
        "Bbr->BandwidthFilter.AppLimited"
      ]
    },
    {
      "line": 125,
      "code": "ASSERT_EQ(Bbr->BandwidthFilter.AppLimitedExitTarget, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->BandwidthFilter.AppLimitedExitTarget",
        "0u"
      ]
    },
    {
      "line": 71,
      "code": "ASSERT_EQ(Bbr->InitialCongestionWindowPackets, 10u);",
      "type": "equality",
      "operands": [
        "Bbr->InitialCongestionWindowPackets",
        "10u"
      ]
    },
    {
      "line": 74,
      "code": "ASSERT_GT(Bbr->CongestionWindow, 0u);",
      "type": "comparison",
      "operands": [
        "Bbr->CongestionWindow",
        "0u"
      ]
    },
    {
      "line": 75,
      "code": "ASSERT_EQ(Bbr->BytesInFlightMax, Bbr->CongestionWindow / 2);",
      "type": "equality",
      "operands": [
        "Bbr->BytesInFlightMax",
        "Bbr->CongestionWindow / 2"
      ]
    },
    {
      "line": 78,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlCanSend, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlCanSend",
        "nullptr"
      ]
    },
    {
      "line": 79,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlSetExemption, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlSetExemption",
        "nullptr"
      ]
    },
    {
      "line": 80,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlReset, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlReset",
        "nullptr"
      ]
    },
    {
      "line": 81,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetSendAllowance, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetSendAllowance",
        "nullptr"
      ]
    },
    {
      "line": 82,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataSent, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataSent",
        "nullptr"
      ]
    },
    {
      "line": 83,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataInvalidated, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataInvalidated",
        "nullptr"
      ]
    },
    {
      "line": 84,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataAcknowledged, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataAcknowledged",
        "nullptr"
      ]
    },
    {
      "line": 85,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataLost, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnDataLost",
        "nullptr"
      ]
    },
    {
      "line": 86,
      "code": "ASSERT_EQ(Connection.CongestionControl.QuicCongestionControlOnEcn, nullptr);  // BBR doesn't implement ECN",
      "type": "equality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnEcn",
        "nullptr"
      ]
    },
    {
      "line": 87,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnSpuriousCongestionEvent, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlOnSpuriousCongestionEvent",
        "nullptr"
      ]
    },
    {
      "line": 88,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlLogOutFlowStatus, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlLogOutFlowStatus",
        "nullptr"
      ]
    },
    {
      "line": 89,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetExemptions, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetExemptions",
        "nullptr"
      ]
    },
    {
      "line": 90,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetBytesInFlightMax, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetBytesInFlightMax",
        "nullptr"
      ]
    },
    {
      "line": 91,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlIsAppLimited, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlIsAppLimited",
        "nullptr"
      ]
    },
    {
      "line": 92,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlSetAppLimited, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlSetAppLimited",
        "nullptr"
      ]
    },
    {
      "line": 93,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetCongestionWindow, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetCongestionWindow",
        "nullptr"
      ]
    },
    {
      "line": 94,
      "code": "ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetNetworkStatistics, nullptr);",
      "type": "inequality",
      "operands": [
        "Connection.CongestionControl.QuicCongestionControlGetNetworkStatistics",
        "nullptr"
      ]
    },
    {
      "line": 97,
      "code": "ASSERT_FALSE(Bbr->BtlbwFound);",
      "type": "boolean",
      "operands": [
        "Bbr->BtlbwFound"
      ]
    },
    {
      "line": 98,
      "code": "ASSERT_FALSE(Bbr->ExitingQuiescence);",
      "type": "boolean",
      "operands": [
        "Bbr->ExitingQuiescence"
      ]
    },
    {
      "line": 99,
      "code": "ASSERT_FALSE(Bbr->EndOfRecoveryValid);",
      "type": "boolean",
      "operands": [
        "Bbr->EndOfRecoveryValid"
      ]
    },
    {
      "line": 100,
      "code": "ASSERT_FALSE(Bbr->EndOfRoundTripValid);",
      "type": "boolean",
      "operands": [
        "Bbr->EndOfRoundTripValid"
      ]
    },
    {
      "line": 101,
      "code": "ASSERT_FALSE(Bbr->AckAggregationStartTimeValid);",
      "type": "boolean",
      "operands": [
        "Bbr->AckAggregationStartTimeValid"
      ]
    },
    {
      "line": 102,
      "code": "ASSERT_FALSE(Bbr->ProbeRttRoundValid);",
      "type": "boolean",
      "operands": [
        "Bbr->ProbeRttRoundValid"
      ]
    },
    {
      "line": 103,
      "code": "ASSERT_FALSE(Bbr->ProbeRttEndTimeValid);",
      "type": "boolean",
      "operands": [
        "Bbr->ProbeRttEndTimeValid"
      ]
    },
    {
      "line": 104,
      "code": "ASSERT_TRUE(Bbr->RttSampleExpired);",
      "type": "boolean",
      "operands": [
        "Bbr->RttSampleExpired"
      ]
    },
    {
      "line": 105,
      "code": "ASSERT_FALSE(Bbr->MinRttTimestampValid);",
      "type": "boolean",
      "operands": [
        "Bbr->MinRttTimestampValid"
      ]
    },
    {
      "line": 108,
      "code": "ASSERT_EQ(Bbr->BbrState, 0u); // BBR_STATE_STARTUP",
      "type": "equality",
      "operands": [
        "Bbr->BbrState",
        "0u"
      ]
    },
    {
      "line": 109,
      "code": "ASSERT_EQ(Bbr->RecoveryState, 0u); // RECOVERY_STATE_NOT_RECOVERY",
      "type": "equality",
      "operands": [
        "Bbr->RecoveryState",
        "0u"
      ]
    },
    {
      "line": 112,
      "code": "ASSERT_EQ(Bbr->BytesInFlight, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->BytesInFlight",
        "0u"
      ]
    },
    {
      "line": 113,
      "code": "ASSERT_EQ(Bbr->Exemptions, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->Exemptions",
        "0u"
      ]
    },
    {
      "line": 114,
      "code": "ASSERT_EQ(Bbr->RoundTripCounter, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->RoundTripCounter",
        "0u"
      ]
    },
    {
      "line": 115,
      "code": "ASSERT_EQ(Bbr->SlowStartupRoundCounter, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->SlowStartupRoundCounter",
        "0u"
      ]
    },
    {
      "line": 116,
      "code": "ASSERT_EQ(Bbr->PacingCycleIndex, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->PacingCycleIndex",
        "0u"
      ]
    },
    {
      "line": 117,
      "code": "ASSERT_EQ(Bbr->AggregatedAckBytes, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->AggregatedAckBytes",
        "0u"
      ]
    },
    {
      "line": 118,
      "code": "ASSERT_EQ(Bbr->LastEstimatedStartupBandwidth, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->LastEstimatedStartupBandwidth",
        "0u"
      ]
    },
    {
      "line": 121,
      "code": "ASSERT_EQ(Bbr->MinRtt, UINT64_MAX);",
      "type": "equality",
      "operands": [
        "Bbr->MinRtt",
        "UINT64_MAX"
      ]
    },
    {
      "line": 124,
      "code": "ASSERT_FALSE(Bbr->BandwidthFilter.AppLimited);",
      "type": "boolean",
      "operands": [
        "Bbr->BandwidthFilter.AppLimited"
      ]
    },
    {
      "line": 125,
      "code": "ASSERT_EQ(Bbr->BandwidthFilter.AppLimitedExitTarget, 0u);",
      "type": "equality",
      "operands": [
        "Bbr->BandwidthFilter.AppLimitedExitTarget",
        "0u"
      ]
    }
  ],
  "raw_lines": [
    {
      "number": 52,
      "content": "TEST(DeepTest_BbrTest, InitializeComprehensive)"
    },
    {
      "number": 53,
      "content": "{"
    },
    {
      "number": 54,
      "content": "    QUIC_CONNECTION Connection;"
    },
    {
      "number": 55,
      "content": "    QUIC_SETTINGS_INTERNAL Settings{};"
    },
    {
      "number": 56,
      "content": ""
    },
    {
      "number": 57,
      "content": "    Settings.InitialWindowPackets = 10;"
    },
    {
      "number": 58,
      "content": "    Settings.SendIdleTimeoutMs = 1000;"
    },
    {
      "number": 59,
      "content": ""
    },
    {
      "number": 60,
      "content": "    InitializeMockConnection(Connection, 1280);"
    },
    {
      "number": 61,
      "content": ""
    },
    {
      "number": 62,
      "content": "    // Pre-set some fields to verify they get initialized"
    },
    {
      "number": 63,
      "content": "    Connection.CongestionControl.Bbr.BytesInFlight = 12345;"
    },
    {
      "number": 64,
      "content": "    Connection.CongestionControl.Bbr.Exemptions = 5;"
    },
    {
      "number": 65,
      "content": ""
    },
    {
      "number": 66,
      "content": "    BbrCongestionControlInitialize(&Connection.CongestionControl, &Settings);"
    },
    {
      "number": 67,
      "content": ""
    },
    {
      "number": 68,
      "content": "    QUIC_CONGESTION_CONTROL_BBR *Bbr = &Connection.CongestionControl.Bbr;"
    },
    {
      "number": 69,
      "content": ""
    },
    {
      "number": 70,
      "content": "    // Verify settings stored correctly"
    },
    {
      "number": 71,
      "content": "    ASSERT_EQ(Bbr->InitialCongestionWindowPackets, 10u);"
    },
    {
      "number": 72,
      "content": ""
    },
    {
      "number": 73,
      "content": "    // Verify congestion window initialized"
    },
    {
      "number": 74,
      "content": "    ASSERT_GT(Bbr->CongestionWindow, 0u);"
    },
    {
      "number": 75,
      "content": "    ASSERT_EQ(Bbr->BytesInFlightMax, Bbr->CongestionWindow / 2);"
    },
    {
      "number": 76,
      "content": ""
    },
    {
      "number": 77,
      "content": "    // Verify all 17 function pointers are set"
    },
    {
      "number": 78,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlCanSend, nullptr);"
    },
    {
      "number": 79,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlSetExemption, nullptr);"
    },
    {
      "number": 80,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlReset, nullptr);"
    },
    {
      "number": 81,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetSendAllowance, nullptr);"
    },
    {
      "number": 82,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataSent, nullptr);"
    },
    {
      "number": 83,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataInvalidated, nullptr);"
    },
    {
      "number": 84,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataAcknowledged, nullptr);"
    },
    {
      "number": 85,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnDataLost, nullptr);"
    },
    {
      "number": 86,
      "content": "    ASSERT_EQ(Connection.CongestionControl.QuicCongestionControlOnEcn, nullptr);  // BBR doesn't implement ECN"
    },
    {
      "number": 87,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlOnSpuriousCongestionEvent, nullptr);"
    },
    {
      "number": 88,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlLogOutFlowStatus, nullptr);"
    },
    {
      "number": 89,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetExemptions, nullptr);"
    },
    {
      "number": 90,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetBytesInFlightMax, nullptr);"
    },
    {
      "number": 91,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlIsAppLimited, nullptr);"
    },
    {
      "number": 92,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlSetAppLimited, nullptr);"
    },
    {
      "number": 93,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetCongestionWindow, nullptr);"
    },
    {
      "number": 94,
      "content": "    ASSERT_NE(Connection.CongestionControl.QuicCongestionControlGetNetworkStatistics, nullptr);"
    },
    {
      "number": 95,
      "content": ""
    },
    {
      "number": 96,
      "content": "    // Verify boolean state flags"
    },
    {
      "number": 97,
      "content": "    ASSERT_FALSE(Bbr->BtlbwFound);"
    },
    {
      "number": 98,
      "content": "    ASSERT_FALSE(Bbr->ExitingQuiescence);"
    },
    {
      "number": 99,
      "content": "    ASSERT_FALSE(Bbr->EndOfRecoveryValid);"
    },
    {
      "number": 100,
      "content": "    ASSERT_FALSE(Bbr->EndOfRoundTripValid);"
    },
    {
      "number": 101,
      "content": "    ASSERT_FALSE(Bbr->AckAggregationStartTimeValid);"
    },
    {
      "number": 102,
      "content": "    ASSERT_FALSE(Bbr->ProbeRttRoundValid);"
    },
    {
      "number": 103,
      "content": "    ASSERT_FALSE(Bbr->ProbeRttEndTimeValid);"
    },
    {
      "number": 104,
      "content": "    ASSERT_TRUE(Bbr->RttSampleExpired);"
    },
    {
      "number": 105,
      "content": "    ASSERT_FALSE(Bbr->MinRttTimestampValid);"
    },
    {
      "number": 106,
      "content": ""
    },
    {
      "number": 107,
      "content": "    // Verify BBR state machine initial state"
    },
    {
      "number": 108,
      "content": "    ASSERT_EQ(Bbr->BbrState, 0u); // BBR_STATE_STARTUP"
    },
    {
      "number": 109,
      "content": "    ASSERT_EQ(Bbr->RecoveryState, 0u); // RECOVERY_STATE_NOT_RECOVERY"
    },
    {
      "number": 110,
      "content": ""
    },
    {
      "number": 111,
      "content": "    // Verify counters initialized"
    },
    {
      "number": 112,
      "content": "    ASSERT_EQ(Bbr->BytesInFlight, 0u);"
    },
    {
      "number": 113,
      "content": "    ASSERT_EQ(Bbr->Exemptions, 0u);"
    },
    {
      "number": 114,
      "content": "    ASSERT_EQ(Bbr->RoundTripCounter, 0u);"
    },
    {
      "number": 115,
      "content": "    ASSERT_EQ(Bbr->SlowStartupRoundCounter, 0u);"
    },
    {
      "number": 116,
      "content": "    ASSERT_EQ(Bbr->PacingCycleIndex, 0u);"
    },
    {
      "number": 117,
      "content": "    ASSERT_EQ(Bbr->AggregatedAckBytes, 0u);"
    },
    {
      "number": 118,
      "content": "    ASSERT_EQ(Bbr->LastEstimatedStartupBandwidth, 0u);"
    },
    {
      "number": 119,
      "content": ""
    },
    {
      "number": 120,
      "content": "    // Verify MinRtt initialized"
    },
    {
      "number": 121,
      "content": "    ASSERT_EQ(Bbr->MinRtt, UINT64_MAX);"
    },
    {
      "number": 122,
      "content": ""
    },
    {
      "number": 123,
      "content": "    // Verify bandwidth filter initialized"
    },
    {
      "number": 124,
      "content": "    ASSERT_FALSE(Bbr->BandwidthFilter.AppLimited);"
    },
    {
      "number": 125,
      "content": "    ASSERT_EQ(Bbr->BandwidthFilter.AppLimitedExitTarget, 0u);"
    },
    {
      "number": 126,
      "content": "}"
    }
  ]
}